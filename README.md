# model
# reltio-gke-with-cloufbuild
![image](https://user-images.githubusercontent.com/4884923/126421829-5fc3fa5a-7b6a-4728-aa93-8a3400d95c16.png)
Objectives
Create Git repositories in GitHub Repositories.
Create a container image with Cloud Build and store it in Container Registry.
Create a CI pipeline.
Create a CD pipeline.
Test the CI/CD pipeline.

Select or create a Cloud project.

Go to Manage Resources

Enable billing for your project.

Enable Billing

Open Cloud Shell to execute the commands listed in this tutorial. Cloud Shell is an interactive shell environment for Google Cloud that lets you manage your projects and resources from your web browser.

Go to Cloud Shell

If the gcloud config get-value project command does not return the ID of the project you selected, configure Cloud Shell to use your project.


gcloud config set project [PROJECT_ID]
In Cloud Shell, enable the required APIs.


gcloud services enable container.googleapis.com \
    cloudbuild.googleapis.com \
    sourcerepo.googleapis.com \
    containeranalysis.googleapis.com
In Cloud Shell, create a GKE cluster that you will use to deploy the sample application of this tutorial.


gcloud container clusters create hello-cloudbuild \
    --num-nodes 1 --zone us-central1-b
If you have never used Git in Cloud Shell, configure it with your name and email address. Git will use those to identify you as the author of the commits you will create in Cloud Shell.


git config --global user.email "[YOUR_EMAIL_ADDRESS]"
git config --global user.name "[YOUR_NAME]"
Run the gcloud credential helper. This will connect your Google Cloud user account to Cloud Source Repositories.


git config --global credential.helper gcloud.sh


Create GitHub Repository:

Git pull the repository and update cloudbuild.yaml with GKE cluster details.

gcloud builds submit .
----
---
e6309f: digest: sha256:d7323bbea61d10c0e05c446c12145045ec871acd6370e2216889d54460c9c552 size: 1995
DONE
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ID                                    CREATE_TIME                DURATION  SOURCE                                                                                    IMAGES                                      STATUS
----
6c52b7d0-73c3-4f71-8b3c-9cb4fbb16ff4  2021-07-21T00:00:33+00:00  24S       gs://cicd-dev-1_cloudbuild/source/1626825632.921691-a225e7f275d44170aa49034f0b6bba2e.tgz  gcr.io/cicd-dev-1/hello-cloudbuild:de6309f  SUCCESS

Cloud Build streams the logs generated by the creation of the container image to your terminal when you execute this command.

After the build finishes, verify that your new container image is available in Container Registry.

Go to Container Registry

hello-cloudbuild image in Container Registry

Creating the continuous integration pipeline
In this section, you configure Cloud Build to automatically run a small unit test, build the container image, and then push it to Container Registry. Pushing a new commit to Cloud Source Repositories automatically triggers this pipeline. The cloudbuild.yaml file included in the code is the pipeline's configuration.

cloudbuild.yamlView on GitHub

steps:
# This step runs the unit tests on the app
- name: 'python:3.7-slim'
  id: Test
  entrypoint: /bin/sh
  args:
  - -c
  - 'pip install flask && python test_app.py -v'

# This step builds the container image.
- name: 'gcr.io/cloud-builders/docker'
  id: Build
  args:
  - 'build'
  - '-t'
  - 'gcr.io/$PROJECT_ID/hello-cloudbuild:$SHORT_SHA'
  - '.'

# This step pushes the image to Container Registry
# The PROJECT_ID and SHORT_SHA variables are automatically
# replaced by Cloud Build.
- name: 'gcr.io/cloud-builders/docker'
  id: Push
  args:
  - 'push'
  - 'gcr.io/$PROJECT_ID/hello-cloudbuild:$SHORT_SHA'
Open the Cloud Build Triggers page.

Go to Triggers

Click Create trigger.

Fill out the following options:

In the Name field, type hello-cloudbuild.
Under Event, select Push to a branch.
Under Source, select hello-cloudbuild-app as your Repository and ^master$ as your Branch.
Under Build configuration, select Cloud Build configuration file.
In the Cloud Build configuration file location field, type cloudbuild.yaml after the /.
Click Create to save your build trigger.

Tip: If you need to create Build Triggers for many projects, you can use the Build Triggers API.

In Cloud Shell, push the application code to Cloud Source Repositories to trigger the CI pipeline in Cloud Build.


cd ~/hello-cloudbuild-app
git push google master
Open the Cloud Build console.

Go to Cloud Build

Your recently run and finished builds appear. You can click on a build to follow its execution and examine its logs.

Creating the continuous delivery pipeline
Cloud Build is also used for the continuous delivery pipeline. The pipeline runs each time a commit is pushed to the candidate branch of the hello-cloudbuild-env repository. The pipeline applies the new version of the manifest to the Kubernetes cluster and, if successful, copies the manifest over to the production branch. This process has the following properties:

The candidate branch is a history of the deployment attempts.
The production branch is a history of the successful deployments.
You have a view of successful and failed deployments in Cloud Build.
You can rollback to any previous deployment by re-executing the corresponding build in Cloud Build. A rollback also updates the production branch to truthfully reflect the history of deployments.
You will modify the continuous integration pipeline to update the candidate branch of the hello-cloudbuild-env repository, triggering the continuous delivery pipeline.

Note: You can extend the system described in this tutorial to manage several environments. The easiest way to achieve this is to have a pair of branches for each environment env: a candidate-env branch and an env branch.
Granting Cloud Build access to GKE
To deploy the application in your Kubernetes cluster, Cloud Build needs the Kubernetes Engine Developer Identity and Access Management Role.

Shell
Console
In the Google Cloud Console, open the Cloud Build Settings page:

Open Cloud Build Settings

The Service account permissions page appears:

Screenshot of the Service account permissions page

Set the status of the Kubernetes Engine Developer role to Enable.

Initializing the hello-cloudbuild-env repository
You need to initialize the hello-cloudbuild-env repository with two branches (production and candidate) and a Cloud Build configuration file describing the deployment process.

In Cloud Shell, clone the hello-cloudbuild-env repository and create the production branch.


cd ~
gcloud source repos clone hello-cloudbuild-env
cd ~/hello-cloudbuild-env
git checkout -b production
Copy the cloudbuild-delivery.yaml file available in the hello-cloudbuild-app repository and commit the change.


cd ~/hello-cloudbuild-env
cp ~/hello-cloudbuild-app/cloudbuild-delivery.yaml ~/hello-cloudbuild-env/cloudbuild.yaml
git add .
git commit -m "Create cloudbuild.yaml for deployment"
The cloudbuild-delivery.yaml file describes the deployment process to be run in Cloud Build. It has two steps:

Cloud Build applies the manifest on the GKE cluster.

If successful, Cloud Build copies the manifest on the production branch.

cloudbuild-delivery.yamlView on GitHub

steps:
# This step deploys the new version of our container image
# in the hello-cloudbuild Kubernetes Engine cluster.
- name: 'gcr.io/cloud-builders/kubectl'
  id: Deploy
  args:
  - 'apply'
  - '-f'
  - 'kubernetes.yaml'
  env:
  - 'CLOUDSDK_COMPUTE_ZONE=us-central1-b'
  - 'CLOUDSDK_CONTAINER_CLUSTER=hello-cloudbuild'

# This step copies the applied manifest to the production branch
# The COMMIT_SHA variable is automatically
# replaced by Cloud Build.
- name: 'gcr.io/cloud-builders/git'
  id: Copy to production branch
  entrypoint: /bin/sh
  args:
  - '-c'
  - |
    set -x && \
    # Configure Git to create commits with Cloud Build's service account
    git config user.email $(gcloud auth list --filter=status:ACTIVE --format='value(account)') && \
    # Switch to the production branch and copy the kubernetes.yaml file from the candidate branch
    git fetch origin production && git checkout production && \
    git checkout $COMMIT_SHA kubernetes.yaml && \
    # Commit the kubernetes.yaml file with a descriptive commit message
    git commit -m "Manifest from commit $COMMIT_SHA
    $(git log --format=%B -n 1 $COMMIT_SHA)" && \
    # Push the changes back to Cloud Source Repository
    git push origin production
Create a candidate branch and push both branches for them to be available in Cloud Source Repositories.


git checkout -b candidate
git push origin production
git push origin candidate
Grant the Source Repository Writer IAM role to the Cloud Build service account for the hello-cloudbuild-env repository.


PROJECT_NUMBER="$(gcloud projects describe ${PROJECT_ID} \
    --format='get(projectNumber)')"
cat >/tmp/hello-cloudbuild-env-policy.yaml <<EOF
bindings:
- members:
  - serviceAccount:${PROJECT_NUMBER}@cloudbuild.gserviceaccount.com
  role: roles/source.writer
EOF
gcloud source repos set-iam-policy \
    hello-cloudbuild-env /tmp/hello-cloudbuild-env-policy.yaml
Creating the trigger for the continuous delivery pipeline
In this section, you configure Cloud Build to be triggered by a push to the candidate branch of the hello-cloudbuild-env repository.

Open the Triggers page of Cloud Build.

Go to Triggers

Click Create trigger.

Fill out the following options:

In the Name field, type hello-cloudbuild-deploy.
Under Event, select Push to a branch.
Under Source, select hello-cloudbuild-env as your Repository and ^candidate$ as your Branch.
Under Configuration, select Cloud Build configuration file (yaml or json).
In the Cloud Build configuration file location field, type cloudbuild.yaml after the /.
Click Create.

Modifying the continuous integration pipeline to trigger the continuous delivery pipeline
In this section, you add some steps to the continuous integration pipeline that generates a new version of the Kubernetes manifest and push it to the hello-cloudbuild-env repository to trigger the continuous delivery pipeline.

Replace the cloudbuild.yaml file with the extended example in the cloudbuild-trigger-cd.yaml file.


cd ~/hello-cloudbuild-app
cp cloudbuild-trigger-cd.yaml cloudbuild.yaml
The cloudbuild-trigger-cd.yaml is an extended version of the cloudbuild.yaml file. It adds steps to generate the new Kubernetes manifest and trigger the continuous delivery pipeline.

Note: This pipeline uses a sed to render the manifest template. In reality, you might benefit from using a dedicated tool such as kustomize or skaffold. These tools give you more control over the rendering of the manifest templates.
cloudbuild-trigger-cd.yamlView on GitHub

# This step clones the hello-cloudbuild-env repository
- name: 'gcr.io/cloud-builders/gcloud'
  id: Clone env repository
  entrypoint: /bin/sh
  args:
  - '-c'
  - |
    gcloud source repos clone hello-cloudbuild-env && \
    cd hello-cloudbuild-env && \
    git checkout candidate && \
    git config user.email $(gcloud auth list --filter=status:ACTIVE --format='value(account)')

# This step generates the new manifest
- name: 'gcr.io/cloud-builders/gcloud'
  id: Generate manifest
  entrypoint: /bin/sh
  args:
  - '-c'
  - |
     sed "s/GOOGLE_CLOUD_PROJECT/${PROJECT_ID}/g" kubernetes.yaml.tpl | \
     sed "s/COMMIT_SHA/${SHORT_SHA}/g" > hello-cloudbuild-env/kubernetes.yaml

# This step pushes the manifest back to hello-cloudbuild-env
- name: 'gcr.io/cloud-builders/gcloud'
  id: Push manifest
  entrypoint: /bin/sh
  args:
  - '-c'
  - |
    set -x && \
    cd hello-cloudbuild-env && \
    git add kubernetes.yaml && \
    git commit -m "Deploying image gcr.io/${PROJECT_ID}/hello-cloudbuild:${SHORT_SHA}
    Built from commit ${COMMIT_SHA} of repository hello-cloudbuild-app
    Author: $(git log --format='%an <%ae>' -n 1 HEAD)" && \
    git push origin candidate
Commit the modifications and push them to Cloud Source Repositories.


cd ~/hello-cloudbuild-app
git add cloudbuild.yaml
git commit -m "Trigger CD pipeline"
git push google master
This triggers the continuous integration pipeline in Cloud Build.

Examine the continuous integration build.

Go to Cloud Build

Your recently run and finished builds for the hello-cloudbuild-app repository appear. You can click on a build to follow its execution and examine its logs. The last step of this pipeline pushes the new manifest to the hello-cloudbuild-env repository, which triggers the continuous delivery pipeline.

Examine the continuous delivery build.

Go to Cloud Build

Your recently run and finished builds for the hello-cloudbuild-env repository appear. You can click on a build to follow its execution and examine its logs.

Testing the complete pipeline
The complete CI/CD pipeline is now configured. In this section, you test it from end to end.

Go to the GKE Services page.

Go to Google Kubernetes Engine Services

The list contains a single service called hello-cloudbuild created by the recently completed continuous delivery build.

Click on the endpoint for the hello-cloudbuild service. "Hello World!" appears. If there is no endpoint, or if you see a load balancer error, you might have to wait a few minutes for the load balancer to be completely initialized. Click Refresh to update the page if needed.

In Cloud Shell, replace "Hello World" by "Hello Cloud Build", both in the application and in the unit test.


cd ~/hello-cloudbuild-app
sed -i 's/Hello World/Hello Cloud Build/g' app.py
sed -i 's/Hello World/Hello Cloud Build/g' test_app.py
Commit and push the change to Cloud Source Repositories.


git add app.py test_app.py
git commit -m "Hello Cloud Build"
git push google master
This triggers the full CI/CD pipeline.

After a few minutes, reload the application in your browser. "Hello Cloud Build!" appears.

Testing the rollback
In this section, you rollback to the version of the application that said "Hello World!".

Open the Cloud Build console for the hello-cloudbuild-env repository.

Go to Cloud Build

Click on the second most recent build available.

Click Rebuild.

When the build is finished, reload the application in your browser. "Hello World!" appears again.


